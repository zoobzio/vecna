---
title: Testing Guide
description: Testing code that uses vecna
author: zoobzio
published: 2025-01-14
updated: 2025-01-14
tags: [vecna, testing, guide]
---

# Testing Guide

Testing code that uses vecna filters.

## Builder Setup

Create the builder once in test setup:

```go
var builder *vecna.Builder[Metadata]

func TestMain(m *testing.M) {
    var err error
    builder, err = vecna.New[Metadata]()
    if err != nil {
        log.Fatal(err)
    }
    os.Exit(m.Run())
}
```

Or create per-test if testing multiple schemas:

```go
func TestWithSchema(t *testing.T) {
    builder, err := vecna.New[Metadata]()
    if err != nil {
        t.Fatal(err)
    }
    // use builder...
}
```

## Testing Filter Construction

### Valid Filters

```go
func TestValidFilter(t *testing.T) {
    filter := builder.Where("category").Eq("tech")

    if err := filter.Err(); err != nil {
        t.Errorf("unexpected error: %v", err)
    }
    if filter.Op() != vecna.Eq {
        t.Errorf("expected Eq, got %v", filter.Op())
    }
    if filter.Field() != "category" {
        t.Errorf("expected category, got %s", filter.Field())
    }
}
```

### Invalid Filters

```go
func TestInvalidField(t *testing.T) {
    filter := builder.Where("nonexistent").Eq("value")

    if err := filter.Err(); err == nil {
        t.Error("expected error for invalid field")
    }
    if !errors.Is(filter.Err(), vecna.ErrFieldNotFound) {
        t.Errorf("expected ErrFieldNotFound, got %v", filter.Err())
    }
}

func TestInvalidOperator(t *testing.T) {
    // Comparison operator on string field
    filter := builder.Where("category").Gt("value")

    if err := filter.Err(); err == nil {
        t.Error("expected error for invalid operator")
    }
    if !errors.Is(filter.Err(), vecna.ErrInvalidFilter) {
        t.Errorf("expected ErrInvalidFilter, got %v", filter.Err())
    }
}
```

## Testing Nested Filters

```go
func TestNestedFilter(t *testing.T) {
    filter := builder.And(
        builder.Where("category").Eq("tech"),
        builder.Or(
            builder.Where("score").Gte(0.8),
            builder.Where("active").Eq(true),
        ),
    )

    if err := filter.Err(); err != nil {
        t.Errorf("unexpected error: %v", err)
    }
    if filter.Op() != vecna.And {
        t.Errorf("expected And, got %v", filter.Op())
    }
    if len(filter.Children()) != 2 {
        t.Errorf("expected 2 children, got %d", len(filter.Children()))
    }

    // Check nested Or
    orFilter := filter.Children()[1]
    if orFilter.Op() != vecna.Or {
        t.Errorf("expected Or, got %v", orFilter.Op())
    }
}
```

## Testing FilterSpec

```go
func TestFromSpec(t *testing.T) {
    spec := &vecna.FilterSpec{
        Op: "and",
        Children: []*vecna.FilterSpec{
            {Op: "eq", Field: "category", Value: "tech"},
            {Op: "gte", Field: "score", Value: 0.8},
        },
    }

    filter := builder.FromSpec(spec)

    if err := filter.Err(); err != nil {
        t.Errorf("unexpected error: %v", err)
    }
    if filter.Op() != vecna.And {
        t.Errorf("expected And, got %v", filter.Op())
    }
}

func TestFromSpecJSON(t *testing.T) {
    jsonData := `{"op":"eq","field":"category","value":"tech"}`

    var spec vecna.FilterSpec
    if err := json.Unmarshal([]byte(jsonData), &spec); err != nil {
        t.Fatal(err)
    }

    filter := builder.FromSpec(&spec)
    if err := filter.Err(); err != nil {
        t.Errorf("unexpected error: %v", err)
    }
}
```

## Testing Schema Extraction

```go
func TestSchema(t *testing.T) {
    spec := builder.Spec()

    if spec.TypeName != "Metadata" {
        t.Errorf("expected Metadata, got %s", spec.TypeName)
    }

    // Check expected fields exist
    expectedFields := []string{"category", "score", "active"}
    for _, name := range expectedFields {
        if spec.Field(name) == nil {
            t.Errorf("expected field %s not found", name)
        }
    }

    // Check field kinds
    if f := spec.Field("score"); f.Kind != vecna.KindFloat {
        t.Errorf("expected KindFloat for score, got %v", f.Kind)
    }
}
```

## Table-Driven Tests

```go
func TestOperators(t *testing.T) {
    tests := []struct {
        name    string
        filter  *vecna.Filter
        wantOp  vecna.Op
        wantErr bool
    }{
        {"eq", builder.Where("category").Eq("tech"), vecna.Eq, false},
        {"ne", builder.Where("category").Ne("tech"), vecna.Ne, false},
        {"gt", builder.Where("score").Gt(0.5), vecna.Gt, false},
        {"gte", builder.Where("score").Gte(0.5), vecna.Gte, false},
        {"lt", builder.Where("score").Lt(0.5), vecna.Lt, false},
        {"lte", builder.Where("score").Lte(0.5), vecna.Lte, false},
        {"in", builder.Where("category").In("a", "b"), vecna.In, false},
        {"invalid field", builder.Where("invalid").Eq("x"), vecna.Eq, true},
        {"gt on string", builder.Where("category").Gt("x"), vecna.Gt, true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.filter.Err()
            if (err != nil) != tt.wantErr {
                t.Errorf("Err() = %v, wantErr %v", err, tt.wantErr)
            }
            if !tt.wantErr && tt.filter.Op() != tt.wantOp {
                t.Errorf("Op() = %v, want %v", tt.filter.Op(), tt.wantOp)
            }
        })
    }
}
```

## Testing Helper Package

vecna provides a `testing` subpackage with helpers:

```go
import vtest "github.com/zoobzio/vecna/testing"

func TestWithHelpers(t *testing.T) {
    builder := vtest.NewTestBuilder[Metadata](t)

    filter := builder.Where("category").Eq("tech")
    vtest.AssertNoError(t, filter)
    vtest.AssertOp(t, filter, vecna.Eq)
    vtest.AssertField(t, filter, "category")
}
```

## Next Steps

- [Troubleshooting](3.troubleshooting.md) — Common issues and solutions
- [API Reference](../4.reference/1.api.md) — Function documentation
