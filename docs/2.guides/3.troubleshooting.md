---
title: Troubleshooting Guide
description: Common issues and solutions for vecna
author: zoobzio
published: 2025-01-14
updated: 2025-01-14
tags: [vecna, troubleshooting, guide]
---

# Troubleshooting Guide

Common issues and their solutions.

## Error: "vecna: type must be a struct"

**Cause:** The type parameter T is not a struct.

```go
// Wrong - string is not a struct
builder, err := vecna.New[string]()
// err: vecna: type must be a struct
```

**Solution:** Use a struct type:

```go
type Metadata struct {
    Category string `json:"category"`
}

builder, err := vecna.New[Metadata]()
```

---

## Error: "vecna: field not found: X"

**Cause:** The field name doesn't exist in the schema.

```go
type Metadata struct {
    Category string `json:"category"`
}

builder, _ := vecna.New[Metadata]()
filter := builder.Where("categroy").Eq("tech")  // typo
// filter.Err(): vecna: field not found: categroy
```

**Solutions:**

1. Check for typos in field names
2. Verify the field exists in your struct
3. Check `json` tags — vecna uses the tag value, not the Go field name

```go
type Metadata struct {
    Category string `json:"category"`  // field name is "category", not "Category"
}

// Correct
filter := builder.Where("category").Eq("tech")

// Wrong - uses Go name instead of json tag
filter := builder.Where("Category").Eq("tech")
```

---

## Error: "vecna: invalid filter: operator X not valid for Y field Z"

**Cause:** Using a comparison operator on a non-numeric field.

```go
type Metadata struct {
    Category string  `json:"category"`
    Score    float64 `json:"score"`
}

builder, _ := vecna.New[Metadata]()
filter := builder.Where("category").Gt("tech")  // Gt on string
// filter.Err(): vecna: invalid filter: operator gt not valid for string field category
```

**Solution:** Use equality operators (`Eq`, `Ne`, `In`) for non-numeric fields:

```go
// Correct
filter := builder.Where("category").Eq("tech")
filter := builder.Where("score").Gt(0.5)  // Gt on float64 is valid
```

---

## Error: "vecna: invalid filter: unknown operator X"

**Cause:** Invalid operator in FilterSpec.

```go
spec := &vecna.FilterSpec{Op: "equals", Field: "category", Value: "tech"}
filter := builder.FromSpec(spec)
// filter.Err(): vecna: invalid filter: unknown operator "equals"
```

**Solution:** Use valid operator strings:

| Valid | Invalid |
|-------|---------|
| `"eq"` | `"equals"`, `"=="` |
| `"ne"` | `"not_equal"`, `"!="` |
| `"gt"` | `"greater"`, `">"` |
| `"gte"` | `"greater_equal"`, `">="` |
| `"lt"` | `"less"`, `"<"` |
| `"lte"` | `"less_equal"`, `"<="` |
| `"in"` | `"contains"` |
| `"and"` | `"AND"`, `"&&"` |
| `"or"` | `"OR"`, `"\|\|"` |

---

## Field Not Appearing in Schema

**Cause:** Field has `json:"-"` tag or is unexported.

```go
type Metadata struct {
    Category string `json:"category"`
    internal string                   // unexported - excluded
    Hidden   string `json:"-"`        // explicitly excluded
}
```

**Solution:** Export the field and use a valid json tag:

```go
type Metadata struct {
    Category string `json:"category"`
    Internal string `json:"internal"`  // now included
}
```

---

## Filter.Err() Returns nil But Query Fails

**Possible causes:**

1. **Value type mismatch** — Filter validates field names and operators, but not value types at build time. A string value for an integer field passes validation but may fail at query time.

2. **Provider-specific requirements** — Some vector databases have additional constraints (e.g., value length limits, reserved characters).

**Solution:** Validate values at the application layer:

```go
func validateScore(v float64) error {
    if v < 0 || v > 1 {
        return fmt.Errorf("score must be between 0 and 1")
    }
    return nil
}
```

---

## Nested Error Not Surfacing

**Cause:** Not calling `Err()` on the final filter.

```go
f1 := builder.Where("valid").Eq("x")
f2 := builder.Where("invalid").Eq("y")  // error here

combined := builder.And(f1, f2)

// Wrong - checking intermediate filter
if f1.Err() != nil { }  // nil

// Correct - check final filter
if combined.Err() != nil { }  // returns nested error
```

**Solution:** Always call `Err()` on the outermost filter. It recursively checks all children.

---

## JSON Unmarshal Fails for FilterSpec

**Cause:** Invalid JSON or type mismatch.

```go
// Wrong - value should be array for "in" operator
jsonData := `{"op":"in","field":"category","value":"tech"}`

// Correct
jsonData := `{"op":"in","field":"category","value":["tech"]}`
```

**Solution:** Validate JSON structure:

- `"in"` operator requires array value
- `"and"`/`"or"` operators require `children` array
- Comparison operators require `field` and `value`

---

## Performance: Slow Filter Construction

**Cause:** Creating builder on every request.

```go
// Wrong - creates builder every time
func handleRequest() {
    builder, _ := vecna.New[Metadata]()  // expensive
    filter := builder.Where("category").Eq("tech")
}
```

**Solution:** Create builder once at startup:

```go
var builder *vecna.Builder[Metadata]

func init() {
    var err error
    builder, err = vecna.New[Metadata]()
    if err != nil {
        log.Fatal(err)
    }
}

func handleRequest() {
    filter := builder.Where("category").Eq("tech")  // cheap
}
```

---

## Next Steps

- [Testing Guide](2.testing.md) — Testing patterns
- [Architecture](../1.learn/4.architecture.md) — Internal design
