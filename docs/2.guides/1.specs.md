---
title: Specs Guide
description: Building filters from JSON with FilterSpec
author: zoobzio
published: 2025-01-14
updated: 2025-01-14
tags: [vecna, specs, json, guide]
---

# Specs Guide

Building filters from serializable specifications.

## Overview

`FilterSpec` enables filter construction from external sources — JSON payloads, configuration files, database records, or LLM-generated queries. The spec is validated against your schema just like fluent-built filters.

## Basic Usage

```go
// Create a spec programmatically
spec := &vecna.FilterSpec{
    Op:    "eq",
    Field: "category",
    Value: "tech",
}

// Convert to validated filter
filter := builder.FromSpec(spec)
if err := filter.Err(); err != nil {
    log.Fatal(err)
}
```

## From JSON

```go
jsonData := `{"op": "eq", "field": "category", "value": "tech"}`

var spec vecna.FilterSpec
if err := json.Unmarshal([]byte(jsonData), &spec); err != nil {
    log.Fatal(err)
}

filter := builder.FromSpec(&spec)
```

## Nested Specs

Logical operators (`and`, `or`) use the `children` field:

```go
jsonData := `{
    "op": "and",
    "children": [
        {"op": "eq", "field": "category", "value": "tech"},
        {"op": "gte", "field": "score", "value": 0.8}
    ]
}`

var spec vecna.FilterSpec
json.Unmarshal([]byte(jsonData), &spec)

filter := builder.FromSpec(&spec)
// Equivalent to:
// builder.And(
//     builder.Where("category").Eq("tech"),
//     builder.Where("score").Gte(0.8),
// )
```

## Deeply Nested Specs

Specs can nest arbitrarily deep:

```go
jsonData := `{
    "op": "and",
    "children": [
        {"op": "eq", "field": "active", "value": true},
        {
            "op": "or",
            "children": [
                {"op": "eq", "field": "category", "value": "tech"},
                {"op": "gte", "field": "score", "value": 0.9}
            ]
        }
    ]
}`
```

## Operator Reference

| Spec Op | Builder Equivalent | Field Required | Value Required |
|---------|-------------------|----------------|----------------|
| `"eq"` | `Where(f).Eq(v)` | Yes | Yes |
| `"ne"` | `Where(f).Ne(v)` | Yes | Yes |
| `"gt"` | `Where(f).Gt(v)` | Yes | Yes |
| `"gte"` | `Where(f).Gte(v)` | Yes | Yes |
| `"lt"` | `Where(f).Lt(v)` | Yes | Yes |
| `"lte"` | `Where(f).Lte(v)` | Yes | Yes |
| `"in"` | `Where(f).In(v...)` | Yes | Yes (array) |
| `"and"` | `And(...)` | No | No |
| `"or"` | `Or(...)` | No | No |

## In Operator

The `in` operator expects an array value:

```go
jsonData := `{
    "op": "in",
    "field": "category",
    "value": ["tech", "science", "art"]
}`
```

## Error Handling

Specs are validated against your schema. Invalid fields or operators produce errors:

```go
// Invalid field
spec := &vecna.FilterSpec{Op: "eq", Field: "nonexistent", Value: "x"}
filter := builder.FromSpec(spec)
// filter.Err(): vecna: field not found: nonexistent

// Invalid operator
spec = &vecna.FilterSpec{Op: "invalid", Field: "category", Value: "x"}
filter = builder.FromSpec(spec)
// filter.Err(): vecna: invalid filter: unknown operator "invalid"

// Type mismatch (comparison on string field)
spec = &vecna.FilterSpec{Op: "gt", Field: "category", Value: "x"}
filter = builder.FromSpec(spec)
// filter.Err(): vecna: invalid filter: operator gt not valid for string field category
```

## Use Cases

### API Endpoints

Accept filter specs from HTTP requests:

```go
func handleSearch(w http.ResponseWriter, r *http.Request) {
    var spec vecna.FilterSpec
    if err := json.NewDecoder(r.Body).Decode(&spec); err != nil {
        http.Error(w, "invalid filter spec", http.StatusBadRequest)
        return
    }

    filter := builder.FromSpec(&spec)
    if err := filter.Err(); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    // Use filter for query...
}
```

### Stored Filters

Save and load filters from a database:

```go
// Save
specJSON, _ := json.Marshal(spec)
db.Exec("INSERT INTO saved_filters (name, spec) VALUES (?, ?)", name, specJSON)

// Load
var specJSON []byte
db.QueryRow("SELECT spec FROM saved_filters WHERE name = ?", name).Scan(&specJSON)
var spec vecna.FilterSpec
json.Unmarshal(specJSON, &spec)
filter := builder.FromSpec(&spec)
```

### LLM Integration

Generate filters from natural language:

```go
// LLM returns JSON spec based on user query
llmResponse := `{"op": "and", "children": [...]}`

var spec vecna.FilterSpec
json.Unmarshal([]byte(llmResponse), &spec)

// Schema validation catches LLM hallucinations
filter := builder.FromSpec(&spec)
if err := filter.Err(); err != nil {
    // LLM generated invalid field name or operator
    return fmt.Errorf("invalid filter from LLM: %w", err)
}
```

## Next Steps

- [Concepts](../1.learn/3.concepts.md) — FilterSpec design rationale
- [API Reference](../4.reference/1.api.md#fromspec) — FromSpec documentation
- [Types Reference](../4.reference/2.types.md#filterspec) — FilterSpec type definition
