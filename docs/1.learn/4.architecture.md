---
title: Architecture
description: System design and internal architecture of vecna
author: zoobzio
published: 2025-01-01
updated: 2025-01-14
tags: [vecna, architecture, design]
---

# Architecture

Internal design for power users and contributors.

## Component Overview

```
┌─────────────────────────────────────────────────────────┐
│                      User Code                          │
│  type Metadata struct { Category string `json:"..."` }  │
└─────────────────────────┬───────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                    vecna.New[T]()                       │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │
│  │  sentinel   │───▶│    Spec     │───▶│  Builder[T] │ │
│  │  (inspect)  │    │  (schema)   │    │  (factory)  │ │
│  └─────────────┘    └─────────────┘    └─────────────┘ │
└─────────────────────────────────────────────────────────┘
                          │
          ┌───────────────┼───────────────┐
          ▼               ▼               ▼
    ┌──────────┐    ┌──────────┐    ┌──────────┐
    │  Where() │    │  And()   │    │ FromSpec │
    │  fluent  │    │  Or()    │    │  (JSON)  │
    └────┬─────┘    └────┬─────┘    └────┬─────┘
         │               │               │
         └───────────────┼───────────────┘
                         ▼
                  ┌─────────────┐
                  │   Filter    │
                  │   (AST)     │
                  └─────────────┘
```

## Package Structure

```
vecna/
├── api.go      # Public types: Filter, Op, FieldKind, Spec
├── builder.go  # Builder[T] and FieldBuilder[T]
├── spec.go     # FilterSpec and FromSpec conversion
└── testing/    # Test helpers and benchmarks
```

## Data Flow

1. **Schema Extraction** — `New[T]()` calls sentinel to inspect the struct
2. **Field Registry** — Field names and types stored in `Builder[T].fields` map
3. **Filter Construction** — `Where()` validates field, returns `FieldBuilder`
4. **AST Building** — Operator methods create `Filter` nodes with deferred errors
5. **Error Surfacing** — `filter.Err()` traverses tree, returns first error

## Sentinel Integration

vecna delegates struct inspection to [sentinel](https://github.com/zoobzio/sentinel):

```
vecna.New[T]()
    └── sentinel.TryInspect[T]()
            └── Returns field names, types, and tags
```

This avoids manual reflection code and leverages sentinel's permanent caching — the schema is extracted once per type across the application lifetime.

## Error Strategy

Errors are deferred to enable fluent construction:

```go
filter := builder.And(
    builder.Where("valid").Eq("x"),
    builder.Where("invalid").Eq("y"),  // error stored here
)
// filter.Err() returns the nested error
```

The `Filter.Err()` method recursively checks children, surfacing the first error encountered. This allows complex trees to be built without interruption.

## Thread Safety

- `Builder[T]` is immutable after creation — safe for concurrent use
- `Filter` instances are immutable — safe to share across goroutines
- `New[T]()` should be called once at startup; reuse the builder

## Design Q&A

**Why defer errors instead of returning them immediately?**

Fluent APIs become awkward with error returns at every step. Deferred errors let you build `And(Where(...).Eq(...), Or(...))` without intermediate error checks, then validate once at the end.

**Why use sentinel instead of direct reflection?**

Sentinel provides permanent caching — the struct is inspected once per type, ever. It also handles edge cases (embedded fields, unexported fields, tag parsing) that raw reflection requires manual handling for.

**Why validate at build time instead of query time?**

Field typos that reach the database often fail silently (empty results) or with cryptic provider-specific errors. Catching them at filter construction gives clear, actionable errors before any network call.

**Why is FilterSpec separate from Filter?**

`Filter` is an internal AST optimized for traversal and provider translation. `FilterSpec` is a serialization format optimized for JSON marshaling and external construction. Keeping them separate allows each to evolve independently.

## Performance

| Operation | Complexity | Notes |
|-----------|------------|-------|
| `New[T]()` | O(n) fields | One-time cost; sentinel caches permanently |
| `Where(field)` | O(1) | Map lookup in field registry |
| `Eq/Ne/Gt/...` | O(1) | Direct struct allocation |
| `And/Or` | O(n) children | Slice allocation |
| `filter.Err()` | O(n) nodes | Tree traversal; short-circuits on first error |
| `FromSpec` | O(n) nodes | Recursive conversion with validation |

Builder creation is the only non-trivial cost, and it's amortized across all filter operations. For hot paths, create the builder once at startup.

## Next Steps

- [API Reference](../4.reference/1.api.md) — Function documentation
- [Types Reference](../4.reference/2.types.md) — Type definitions
