---
title: Concepts
description: Core concepts and design principles of vecna
author: zoobzio
published: 2025-01-01
updated: 2025-01-14
tags: [vecna, concepts, design]
---

# Concepts

Mental models for working with vecna.

## Schema-First Validation

vecna validates filter field names against your Go struct at build time. This catches typos and invalid fields immediately:

```go
builder.Where("categroy").Eq("tech")  // Error: field not found
builder.Where("category").Eq("tech")  // Valid
```

The schema is extracted once when you call `New[T]()` and reused for all filter construction. See [Builder](../4.reference/1.api.md#builder) in the API reference.

## Field Name Resolution

Field names are resolved in order:

1. `json` tag value (e.g., `json:"category"` → `"category"`)
2. Go field name (e.g., `Category` → `"Category"`)

Fields with `json:"-"` are excluded from the schema entirely.

```go
type Metadata struct {
    Category string `json:"category"` // field name: "category"
    Score    float64                  // field name: "Score"
    Internal string `json:"-"`        // excluded
}
```

## Deferred Error Handling

vecna uses deferred error handling. Invalid filters don't panic — they carry an error that surfaces when you call `filter.Err()`:

```go
filter := builder.And(
    builder.Where("valid").Eq("value"),
    builder.Where("invalid").Eq("value"),  // Error stored here
)

// Check once at the end
if err := filter.Err(); err != nil {
    // Handle error
}
```

This allows building complex filter trees without checking errors at each step. The `Err()` method recursively checks all children, returning the first error encountered.

## Type Validation

Comparison operators (`Gt`, `Gte`, `Lt`, `Lte`) only work on numeric fields:

```go
builder.Where("score").Gte(0.8)     // Valid (float64)
builder.Where("category").Gt("a")  // Error: not numeric
```

Equality operators (`Eq`, `Ne`, `In`) work on all field types. See [Operators](../4.reference/2.operators.md) for the complete list.

## Filter AST

Filters form an abstract syntax tree (AST):

```
And
├── Eq(category, "tech")
└── Or
    ├── Gte(score, 0.8)
    └── Eq(active, true)
```

The AST can be traversed using accessor methods:

| Method | Returns | Description |
|--------|---------|-------------|
| `Op()` | `Op` | Operator type (Eq, And, etc.) |
| `Field()` | `string` | Field name (empty for And/Or) |
| `Value()` | `any` | Comparison value (nil for And/Or) |
| `Children()` | `[]*Filter` | Child filters (nil for field conditions) |
| `Err()` | `error` | First error in tree, or nil |

See [Filter](../4.reference/2.types.md#filter) in the types reference.

## FilterSpec

`FilterSpec` enables filter construction from external sources — JSON payloads, config files, or LLM-generated queries:

```go
spec := &vecna.FilterSpec{
    Op: "and",
    Children: []*vecna.FilterSpec{
        {Op: "eq", Field: "category", Value: "tech"},
        {Op: "gte", Field: "score", Value: 0.8},
    },
}

filter := builder.FromSpec(spec)
```

The spec is validated against the schema just like fluent-built filters. See the [Specs Guide](../2.guides/1.specs.md) for complete coverage.

## Next Steps

- [Architecture](4.architecture.md) — Internal design and data flow
- [API Reference](../4.reference/1.api.md) — Function documentation
- [Types Reference](../4.reference/2.types.md) — Type definitions
